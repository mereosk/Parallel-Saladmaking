ΠΑΝΕΠΙΣΤΗΜΙΟ ΑΘΗΝΩΝ 
Τμήμα Πληροφορικής και Τηλεπικοινωνιών 
3η Εργασία - Τμήμα: Περιττών Αριθμών Μητρώου 
Κ22: Λειτουργικά Συστήματα – Χειμερινό Εξάμηνο ΄20


Κωνσταντίνος Μερεός  s

_______________________________________________________________________________________________________________________________________________

Execution and Separate Compilation
Το πρόγραμμά μου αποτελείται από τέσσερις φακέλους, include, misc, modules, programs. Στον φάκελο programs υπάρχουν τα δύο κύρια προγράμματα της άσκησης, το chef.c καθώς και το saladmaker.c, τα οποία έχουν τις βασικές λειτουργίες του σεφ και των σαλατοποιών αντίστοιχα. Στη συνέχεια υπάρχουν κάποια προγράμματα που δρουν επικουρικά στα κύρια αρχεία κώδικα. Τα chef_help.c και saladmaker_help.c έχουν συναρτήσεις που βοηθούν τα κύρια προγράμματα, το shared_memory.c περιέχει λειτουργίες γύρω από την shared memory και τέλος υπάρχει το help_funcs.c το οποίο έχει συναρτήσεις που βοηθούν και τα δύο κύρια αρχεία. Φυσικά οι αρχικοποιήσεις των συναρτήσεων αλλά και των δομών των προηγούμενων γίνεται στον φάκελο include στα αρχεία κεφαλίδας. Ο φάκελος misc αρχικά δεν περιέχει τίποτα, στη συνέχεια όμως, για κάθε τρέξιμο του προγράμματος δημιουργείται ένας φάκελος όπου μέσα του εισάγονται όλα τα log αρχεία που ζητάει η άσκηση. Τέλος στον φάκελο programs υπάρχει και το Makefile το οποίο έχει τις εξείς λειτουργίες:
* Μπορεί να δημιουργήσει τα εκτελέσιμα αρχεία chef και saladmaker με τις παρακάτω εντολές
$make chef
$make saladmaker
Ή ακόμα να τα δημιουργήσει και τα δύο με ένα απλό
$make
* Μπορεί να τρέξει το εκτελέσιμο chef. Αν θέλω να αλλάξω τα arguments που περνάω στο terminal πάω στο Makefile και αλλάζω τις τιμές στη μεταβλητή ARGS.
$make run
* Μπορεί να τρέξει το εκτελέσιμο saladmaker. Αν θέλω να αλλάξω τα arguments που περνάω στο terminal πάω στο Makefile και αλλάζω τις τιμές στη μεταβλητή ARGSS.
$make runn
* Μπορεί να τρέξει τα εκτελέσιμα μέσω του valgrind με την ίδια λογική με τα δύο προηγούμενα bullets.
$make valgrind        (για το chef)
$make valgrindd        (για το saladmaker)
* Μπορεί να διαγράψει όλα τα εκτελέσιμα και αντικειμενικά αρχεία του project καθώς και όλα τα log files, που βρίσκονται μέσα στο misc, και τους φακέλους που τα περιέχουν με την εντολή:
$make clean

Εγώ για να τρέξω το πρόγραμμα έκανα τα παρακάτω βήματα:
* Ανοίγω 4 tty’s.
* Σε ένα από αυτά γράφω την εντολή make run.
* Βάζω το id, που επιστρέφει η κοινή μνήμη και εκτυπώνεται στο stdout, στα ARGSS στη σημαία -s.
* Στα 3 ttys για τους saladmakers γράφω την εντολή make runn προσέχοντας κάθε φορά να αλλάζω στο Makefile στην μεταβλητή ARGS το  flag -i, ώστε να παίρνει τις τιμές από 0 μέχρι 2. Ο λόγος είναι ότι κάθε τιμή είναι και άλλος σαλατοποιός.


Chef.c
Το πρόγραμμα του σεφ ξεκινάει διαβάζοντας την είσοδο από το terminal. Λειτουργεί για όποια σειρά και να βάλουμε τις σημαίες αλλά και τσεκάρει για την τήρηση των περιορισμών όπως για παράδειγμα να μην έχει εισαχθεί αρνητική τιμή για τις σαλάτες. Στη συνέχεια, φτιάχνει την κοινή μνήμη, παίρνοντας το id και εκτυπώνοντας το, ώστε να περαστεί στη συνέχεια στους saladmakers από τα ορίσματα που τους περνάω στο terminal. Μετά, κάνω attach τη shared memory,όπου η επιστρέφουσα τιμή είναι το address space της κοινής μνήμης. Για αυτό το λόγο βάζω έναν δείκτη, sMemory, να δείχνει σε αυτή τη διεύθυνση. Ο προηγούμενος, είναι δείκτης σε ένα struct sharedMemory στο οποίο τοποθετώ όλους τους σημαφόρους αλλά και διάφορες μεταβλητές, τις οποίες θέλω να μοιράζονται όλα τα κύρια προγράμματά μου, όπως ο αριθμός των σαλατών που έχουν απομείνει αλλά και το path του φακέλου που θα φτιαχτεί για να εμπεριέχει τα log files. Μιλώντας για τον φάκελο, φτιάχνεται στη συνέχεια μαζί με το pathname του global log file. 

Αφού αρχικοποιηθούν όλες οι τιμές και οι σημαφόροι μέσα στην κοινή μνήμη, αρχίζει η αέναη επανάληψη (στην οποία φυσικά υπάρχει και μια διαδικασία για να φύγει ο σεφ από αυτή). Δεν θα μιλήσω για το concurrency μεταξύ σεφ και σαλατοποιών, καθώς το αναπτύσσω πιο κάτω. Στην αρχή της επανάληψης ο σεφ επιλέγει τα υλικά που θα αφήσει στο τραπέζι μέσω της συνάρτησης selectIngredients. H προηγούμενη βρίσκει τυχαία έναν αριθμό από το 0 μέχρι και το 2, αυτός είναι ουσιαστικά ποιός σαλατοποιός θα πάρει τα υλικά. Έτσι αν για παράδειγμα τύχει το 0 θα δώσει τα υλικά που χρειάζεται ο πρώτος σαλατοποιός, δηλαδή πιπεριά και κρεμμύδι. Τα υλικά έχουν τη μορφή enums. Όμως, ο αλγόριθμος δεν επιλέγει υλικά που επέλεξε την προηγούμενη επανάληψη ( το είδα από ένα post στο piazza). Tέλος επιστρέφει τον αριθμό ώστε να ειδοποιήσει τον κατάλληλο σαλατοποιό. Αφού πάρει την τιμή κάνει notify τον σαλατοποιό, περιμένει τον προηγούμενο ώστε να πάρει τα υλικά και ξεκουράζεται για χρόνο mantime. Όλα αυτά εκτυπώνονται και στο stdout αλλά και στο global log αρχείο στη μορφή που μας είπατε. Αυτό το καταφέρνω με τις gettimeofday, gmtime και convertTimeToString. Η τελευταία συνάρτηση παίρνει την συγκεκριμένη μέρα, ώρα, λεπτό, δευτερόλεπτο που προκύπτουν από την gmtime και το μιλιδευτερόλεπτο από την gettimeofday και τα μετατρέπει σε συμβολοσειρά. Μετά “κλείνω” το γράψιμο στο global log file σε έναν mutex writingToGLogMutex ώστε να μην έχω ποτέ δύο writers να γράφουν ταυτόχρονα. Επίσης για να μην ανοιγοκλείνω συνέχεια το file μετά από κάθε γράψιμο εκτελώ και το fflush(fp). Αφού τελειώσει η επανάληψη (φτιάχνονται όλες οι σαλάτες) εκτυπώνω τα ζητούμενη (σαλάτες που φτιάχτηκαν, πόσες ο έφτιαξε ο κάθε σαλατοποιός, τα χρονικά διαστήματα στα οποία 2 η πιο πολλές διεργασίες δρουν ταυτόχρονα). Τέλος, ελευθερώνω όλη τη μνήμη που δέσμευσα αλλά και αφαιρώ το shared memory segment.


Saladmaker.c
Το πρόγραμμα του σαλατοποιού ξεκινάει διαβάζοντας την είσοδο από το terminal. Λειτουργεί για όποια σειρά και να βάλουμε τις σημαίες αλλά και τσεκάρει την τήρηση των περιορισμών, όπως για παράδειγμα να μην έχει εισαχθεί αρνητική τιμή για το κατώτερο χρονικό διάστημα. Εκτός από τα ορίσματα που προτείνει να βάλουμε η εκφώνηση, έβαλα και έναν ακέραιο από 0 εώς και το 2 για να ξεχωρίζει ο ένας σαλατοποιός με τον άλλο. Στη συνέχεια βρίσκω το τυχαίο χρονικό διάστημα που θα φτιάχνει τις σαλάτες ο σαλατοποιός μέσω της συνάρτησης timeForMakingSalad και κάνω attach το shared memory segment. Μετά φτιάχνω το προσωπικό log file στο οποίο θα γράφω την πρόοδο του σαλατοποιού μέσα στο φάκελο που έχει δημιουργήσει ο σεφ. Έπειτα ξεκινάει η επανάληψη και όπως πριν δεν θα μιλήσω για το concurrency μεταξύ σαλατοποιού και σεφ, αφού το αναλύω παρακάτω. Πρώτα ο σαλατοποιός περιμένει τα υλικά, στη συνέχεια τα παίρνει και ενημερώνει τον σεφ για αυτό και τέλος φτιάχνει τη σαλάτα. Όταν φτιάξει τη σαλάτα μειώνει την μεταβλητή saladsLeft που βρίσκεται στην κοινή μνήμη. Αλλά, επειδή όλοι οι σαλατοποιοί βρίσκονται σε παραλληλισμό (σχεδόν) πρέπει να κλείσω την πράξη στο mutex mutexForSaladsCS. Στη συνέχεια, αυξάνει τις συνολικές σαλάτες που έχει φτιάξει ο ίδιος κατά μία ( η μεταβλητή υπάρχει στην κοινή μνήμη). Όλες οι άλλες λειτουργίες είναι ίδιες με αυτές του σεφ που περιέγραψα από πάνω εκτός του ότι κάθε φορά γράφει και στο προσωπικό του log αρχείο, εκτός του global και του stdout. Τέλος αποδεσμεύει τη μνήμη που έχει δεσμεύσει και κάνει detach το shared memory segment.


Concurrency between chef and saladmakers
Όλοι οι σημαφόροι βρίσκονται στην κοινή μνήμη. Αρχικά, υπάρχει ένας πίνακας από 3 σημαφόρους notifySaladmakers (ένας για κάθε σαλατοποιό). Κάθε σημαφόρος αρχικοποιείται με το 0 και χρησιμοποιείται, όπως λέει το όνομά του, όταν διαλέγει τα υλικά ο σεφ και θέλει να καλέσει τον σαλατοποιό ο οποίος τα χρειάζεται. Έτσι αν περιμένει ο σαλατοποιός υλικά γίνεται suspended στον σημαφόρο του στον πίνακα. Το post, για να σταματήσει να είναι blocked ο σαλατοποιός, το εκτελεί ο σεφ όταν έχει τα υλικά. Στη συνέχεια, ο σεφ γίνεται suspended στον σημαφόρο notifyChef(αρχικοποίηση με 0) ώστε να περιμένει τον σαλατοποιό να του “πει” ότι τα πήρε. Έτσι όταν τα πάρει κάνει post στον προηγούμενο σημαφόρο για να ενημερώσει τον σεφ και να συνεχίσουν.

Όταν ένας σαλατοποιός φτιάξει και την τελευταία σαλάτα, η μεταβλητή saladsLeft θα γίνει 0 και πρέπει και τα 4 προγράμματα να τερματίσουν. Ο σεφ, στην αρχή της επανάληψης, τσεκάρει αν οι σαλάτες που έχουν απομείνει είναι 0 (ή μικρότερες), ώστε να τερματίσει . Επίσης, κάθε φορά που ένας σαλατοποιός γίνεται ενεργός αλλά και κάθε φορά που τελειώνει τη σαλάτα (γίνεται ανενεργός), βλέπει, και αυτός, την τιμή των σαλατών ώστε να τερματίσει. Όμως υπάρχουν τρία ενδεχόμενα:
1. Όλοι οι σαλατοποιοί να δουν την τιμή όπου όλα βαίνουν καλώς με όλες τις διεργασίες να συνεχίζουν μετά τις επαναλήψεις.
2. Κάποιος/οι σαλατοποιός περιμένει υλικά. Για να το αντιμετωπίσει αυτό o σεφ εκτελεί ένα post σε όλους τους notifySaladmakers σημαφόρους. Έτσι αν κάποιος σαλατοποιός έχει γίνει suspended εκεί θα συνεχίσει και θα δει την τιμή των σαλατών.
3. Κάποιος/οι σαλατοποιοί φτιάχνουν ακόμα σαλάτες τη στιγμή που γίνονται αυτές 0. Σε αυτήν την περίπτωση απλά ο σαλατοποιός όταν τελειώσει την σαλάτα θα δει ότι η τιμή του saladsLeft είναι μικρότερη του 0. Έτσι μπορεί να έχουν φτιαχτεί συνολικά 1-2 σαλάτες παραπάνω από αυτές που θέλαμε.
Μια τελευταία λεπτομέρεια・ο σεφ θέλουμε να τερματίσει τελευταίος καθώς μπορεί να προκύψουν προβλήματα σε αντίθετη περίπτωση. Για παράδειγμα, όταν εκτυπώνει τα time intervals και δεν έχει προλάβει να τελειώσει ένας σαλατοποιός, δεν θα έχει γραφτεί ακόμα όλο το global log file. Για αυτό το λόγο υπάρχει ένας σημαφόρος notifySaladmakersEnd (0 αρχικοποίηση) στον οποίο ο σεφ γίνεται suspended 3 φορές και όταν τελειώνει ένας σαλατοποιός κάνει post. Έτσι ο σεφ απελευθερώνεται και βγαίνει από την επανάληψη όταν τελειώσει και ο τελευταίος σαλατοποιός.


Time Intervals
Αυτή τη λειτουργία την εκτελεί η συνάρτηση printTimeIntervals στο chef.c. Επέλεξα να μετρήσω μόνο τους σαλατοποιούς καθώς το είδα σε ένα post στο piazza. Αρχικά, η συνάρτηση, διαβάζει το global αρχείο σειρά σειρά. Σε κάθε σειρά απομονώνονται τα κομμάτια ενδιαφέροντος, που είναι ο χρόνος, ποιός είναι (πχ saladmaker1) και το μήνυμα, μέσω της συνάρτησης strtok. Στη συνέχεια, ενεργός θεωρείται ο σαλατοποιός από τη στιγμή που παίρνει τα υλικά μέχρι που τελειώνει τη σαλάτα. Την έννοια του “ενεργού” την έχω υλοποιήσει μέσω τριών bool μεταβλητών, μία για κάθε σαλατοποιό (true = ενεργός, false = ανενεργός). Έτσι τα μηνύματα ενδιαφέροντος είναι το “Get ingredients” και το “End making salad”. Αν το μήνυμα είναι ότι πήρε τα υλικά τότε υπάρχουν 3 επιλογές.
1. Να μην υπάρχει κανένας άλλος ενεργός που τότε απλά αλλάζει η τιμή της μεταβλητής του σαλατοποιού σε true.
2. Να υπάρχει ένας που είναι ενεργός. Τότε εκτυπώνεται ο start time του concurrency 2 διεργασιών και αλλάζει και η μεταβλητή σε true.
3. Να είναι και οι δύο άλλοι σαλατοποιοί ενεργοί. Αυτό σημαίνει ότι τελειώνει η ταυτόχρονη λειτουργία των δύο σαλατοποιών (εκτυπώνω το end time 2 concurrency) και ξεκινάει το concurrency 3 σαλατοποιών (εκτυπώνω το start time του ταυτοχρονισμού τριών διεργασιών).
Για το μήνυμα “End making salad” τα πράγματα είναι ακριβώς αντίθετα (δεν το παραθέτω καθώς δεν θέλω να σας κουράσω).


Ευχαριστώ πολύ για την υπομονή και τον χρόνο σας.
